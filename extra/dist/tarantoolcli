#!/usr/bin/env tarantool

local io       = require('io')
local fun      = require('fun')
local log      = require('log')
local json     = require('json')
local xlog     = require('xlog')
local yaml     = require('yaml')
local remote   = require('net.box')
local console  = require('console')
local argparse = require('internal.argparse').parse

local function find_space(sid, spaces)
    if type(spaces) == 'number' then
        return sid == spaces
    end
    local shown = false
    for _, v in ipairs(spaces) do
        if v == sid then
            shown = true
            break
        end
    end
    return shown
end

local write_lua_table = nil

-- escaped string will be written
local function write_lua_string(string)
    io.stdout:write("'")
    local pos, byte = 1, string:byte(1)
    while byte ~= nil do
        io.stdout:write(("\\x%x"):format(byte))
        pos = pos + 1
        byte = string:byte(pos)
    end
    io.stdout:write("'")
end

local function write_lua_value(value)
    if type(value) == 'string' then
        write_lua_string(value)
    elseif type(value) == 'table' then
        write_lua_table(value)
    else
        io.stdout:write(tostring(value))
    end
end

local function write_lua_fieldpair(key, val)
    io.stdout:write("[")
    write_lua_value(key)
    io.stdout:write("] = ")
    write_lua_value(val)
end

write_lua_table = function(tuple)
    io.stdout:write('{')
    local is_begin = true
    for key, val in pairs(tuple) do
        if is_begin == false then
            io.stdout:write(', ')
        else
            is_begin = false
        end
        write_lua_fieldpair(key, val)
    end
    io.stdout:write('}')
end

local function cat_lua_cb(record)
    io.stdout:write(('box.space[%d]'):format(record.BODY.space_id))
    local op = record.HEADER.type:lower()
    io.stdout:write((':%s('):format(op))
    if op == 'insert' or op == 'replace' then
        write_lua_table(record.BODY.tuple)
    elseif op == 'delete' then
        write_lua_table(record.BODY.key)
    elseif op == 'update' then
        write_lua_table(record.BODY.key)
        io.stdout:write(', ')
        write_lua_table(record.BODY.tuple)
    elseif op == 'upsert' then
        write_lua_table(record.BODY.tuple)
        io.stdout:write(', ')
        write_lua_table(record.BODY.operations)
    end
    io.stdout:write(')\n')
end

local function cat_yaml_cb(record)
    print(yaml.encode(record):sub(1, -6))
end

local function cat_json_cb(record)
    print(json.encode(record))
end

local cat_formats = setmetatable({
    yaml = cat_yaml_cb,
    json = cat_json_cb,
    lua  = cat_lua_cb,
}, {
    __index = function(self, cmd)
        error(("Unknown formatter '%s'"):format(cmd))
    end
})

local function cat_command(files, options)
    local from, to, spaces = options.from, options.to, options.spaces
    local show_system, cat_format = options['show-system'], options.format

    local format_cb   = cat_formats[cat_format]
    local is_printed  = false
    for id, file in ipairs(files) do
        log.info(("Processing file '%s'"):format(file))
        for lsn, record in xlog.pairs(file) do
            local sid = record.BODY.space_id
            if (lsn < from) or
               (sid < 512 and show_system == false) or
               (spaces ~= nil and find_space(sid, spaces)) then
                -- pass this tuple
            elseif lsn > to then
                -- stop, as we've had finished reading tuple with lsn == to
                -- and next lsn's will be bigger
                break
            else
                is_printed = true
                format_cb(record)
                io.stdout:flush()
            end
        end
        if options.format == 'yaml' and is_printed then
            is_printed = false
            print('...\n')
        end
    end
end

local function play_command(files, options)
    local from, to, spaces = options.from, options.to, options.spaces
    local show_system = options['show-system']
    local uri = table.remove(files, 1)

    if uri == nil then
        error("Empty URI is provided")
    end
    local receiver = remote.new(uri)
    if receiver:wait_connected() == 'closed' then
        error(("Error, while connecting to host '%s'"):format(uri))
    end
    for id, file in ipairs(files) do
        log.info(("Processing file '%s'"):format(file))
        for lsn, record in xlog.open(file) do
            local sid = record.BODY.space_id
            if (lsn < from) or
               (sid < 512 and show_system == false) or
               (spaces ~= nil and find_space(sid, spaces)) then
                -- pass this tuple
            elseif lsn > to then
                -- stop, as we've had finished reading tuple with lsn == to
                -- and next lsn's will be bigger
                break
            else
                local args, so = {}, receiver.space[sid]
                table.insert(args, so)
                table.insert(args, record.BODY.key)
                table.insert(args, record.BODY.tuple)
                table.insert(args, record.BODY.operations)
                -- print(record.HEADER.type:lower(), yaml.encode(args))
                so[record.HEADER.type:lower()](unpack(args))
            end
        end
    end
    receiver:close()
end

local function connect_command(options, arguments)
    local uri = table.remove(options)
    console.on_start(function(self)
        local status, reason
        status, reason = pcall(function() require('console').connect(uri) end)
        if not status then
            self:print(reason)
            self.running = false
        end
    end)
    console.on_client_disconnect(function(self) self.running = false end)
    console.start()
    return 0
end

--[[--
local function help_command(cmd_name)
end
--]]--

local commands = setmetatable({
    cat     = cat_command,
    play    = play_command,
    connect = connect_command,
}, {
    __index = function(self, cmd)
        error(("Unknown comamnd '%s'"):format(cmd))
    end
})

local function parameters_populate(parameters)
    parameters                = parameters                or {}
    parameters.from           = parameters.from           or 0
    parameters.to             = parameters.to             or -1ULL
    parameters['show-system'] = parameters['show-system'] or false
    parameters.format         = parameters.format         or 'yaml'
    return parameters
end

-- returns command name, file list and named parameters
local function parameters_parse(parameters)
    local cmd_name = table.remove(parameters, 1)
    local files = {}
    while true do
        local elem = table.remove(parameters, 1)
        if elem == nil then
            break
        end
        table.insert(files, elem)
    end
    return cmd_name, files, parameters
end

local parameters = argparse(arg, {
    { 'space',        'number+' },
    { 'show-system',  'boolean' },
    { 'from',         'number'  },
    { 'to',           'number'  },
    { 'help',         'boolean' },
    { 'format',       'string'  }
})

local cmd_name, files, parameters = parameters_parse(parameters)
print(yaml.encode(files))
if cmd_name == 'help' or parameters.help == true then
    help_command(cmd_name)
end
parameters = parameters_populate(parameters)

commands[cmd_name](files, parameters)

os.exit(0)

-- vim: syntax=lua
